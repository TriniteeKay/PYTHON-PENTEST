import os
import time
import ssl
import nmap
import time
import psutil
import socket
import asyncio
import aiohttp
import logging
import requests
import platform
import subprocess
import scapy.all as scapy
import concurrent.futures
from rich import print
from rich.table import Table
from datetime import datetime
# from api_app import start_server
from rich.console import Console
from rich.logging import RichHandler
from rich.console import Console
from rich.markdown import Markdown
from scapy.layers.inet import IP, TCP, UDP
from requests.exceptions import SSLError, ConnectTimeout

from fastapi import FastAPI
from pydantic import BaseModel
# from pentest import Pentester
import uvicorn

class CustomFormatter(logging.Formatter):
    def format(self, record):
        record.timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        return super().format(record)

class InputValidator:
    """A string validator class"""
    def __init__(self): pass
    def is_int(self, obj, raise_error:bool=False):
        if isinstance(obj, str): 
            for i, j in enumerate(obj):
                if not j.isdigit() and j != '.':
                    if raise_error: raise ValueError(f'Object contains a non-numeric value "{j}" at index {i}.')
                    else: return False
            return True
        else:
            if raise_error: raise TypeError(f'Object must be a string but is of invalid type {type(obj)}.')
            else: return False
        
    def is_str(self, obj, length:int=None, length_limit:list=None, raise_error:bool=False):
        if isinstance(obj, str):
            if not (length and length == len(obj)):
                if raise_error: raise Exception('Invalid number of characters detected. You can only enter %s number of character.'%(length))
                else: return False
            for i in obj:
                if not obj.isalpha():
                    if raise_error: raise ValueError('Non-alphabetic character identified')
                    else: return False
            else:
                return True
        else: 
            if raise_error: raise ValueError('The object passed is not a string.')
            else: return False

class Pentester:
    """
The Pentester is a python class with several methods to carry out penetration tests ranging from .
These are the methods used in carry out the different penetration tests>
---------------------------------------------------------------
'port_scanner',
'scan_headers',
'scan_port_mltd',
'port_scanner_mltd',
'detailed_network_scan',
'sniff_wireless_networks',
'check_dos_protection_mltd',
'check_dos_protection_asyncio',
'check_certificate_expiry',
'check_ssl_tls_configuration',
'check_waf_presence',
---------------------------------------------------------------
    """

    __doc_actions__ = """
# The Pentester

The Pentester is a Python class with several methods to carry out penetration tests.

---

## Information Gathering

1. **get_banner():**
    - Retrieves the welcome banner message from a target system.

2. **get_banner_mltd():**
    - *Multi-threaded:* Retrieves the welcome banner message from a target system. (This likely utilizes multiple threads for faster execution)

3. **get_channel():**
    - Identifies the wireless channel used by an access point (if applicable).

4. **get_mac_address():**
    - Retrieves the MAC address of a target system (requires network proximity).

5. **get_network_banner():**
    - Retrieves the network banner information from a target system.

---

## Network Scanning

1. **detailed_network_scan():**
    - Performs a comprehensive network scan on a target system, likely including vulnerability checks.

2. **port_scanner():**
    - Scans ports on a target system to identify open ports and potential services.

3. **port_scanner_mltd():**
    - *Multi-threaded:* Scans ports on a target system, likely utilizing multiple threads for faster execution.

4. **sniff_wireless_networks():**
    - Captures and analyzes traffic on nearby wireless networks (requires appropriate hardware).

---

## Vulnerability Assessment (Limited due to Security Concerns)

1. **check_ssl_tls_configuration():**
    - Analyzes the SSL/TLS configuration of a target system for potential weaknesses (use with caution).

---

## Web Application Testing (Limited due to Security Concerns)

1. **scan_headers():**
    - Scans headers of a website for potential vulnerabilities (use with caution).

---

## Denial-of-Service (DoS) Testing (Not Recommended - for Educational Purposes Only)

1. **check_dos_protection_asyncio():**
    - *Asynchronous:* Checks for DoS protection mechanisms on a target system (for educational purposes only, never use for malicious intent).

2. **check_dos_protection_mltd():**
    - *Multi-threaded:* Checks for DoS protection mechanisms on a target system (for educational purposes only, never use for malicious intent).

---

**Please select the number corresponding to the desired action or '0' to exit:**

---

**Important Note:**

- Functions related to DoS testing are included for educational purposes only. Never use them for malicious intent.
- Functions related to vulnerability assessment and web application testing should only be used on authorized systems with permission.

"""

    def __init__(self, *args, **kwargs):
        self.website_url = None
        self.ip_addr = None
        self.port = None
        self.tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.timeout = 1
        self.console = Console(color_system='256')
        self.start_time = datetime.now()
        self.handler = RichHandler(console=self.console, show_time=True)
        self.handler.setFormatter(CustomFormatter())    
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        self.logger.addHandler(self.handler)

    def get_banner(self, socket_obj):
        try:
            # Receive up to 1024 bytes of data from the socket
            banner = socket_obj.recv(1024).decode('utf-8').strip()
            return banner
        except socket.timeout:
            return "Timeout"
        except UnicodeDecodeError:
            return "Unable to decode banner"
        except ConnectionResetError:
            return "The connection was terminated, reduce your timeout"
        except ConnectionRefusedError:
            return "The connection was refused by the machine"
        except Exception as e:
            return f"An error occured: {e}"

    def tcp_scan(self, address: tuple, open_ports: dict, timeout, verbose):
        self.tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.tcp.settimeout(timeout)  # Corrected usage of settimeout
        ip = address[0]
        port = address[1]
        if len(address) > 2:
            raise Exception("Invalid address format")
        result = self.tcp.connect_ex((ip, port))
        if verbose:
            self.console.log(f'scanned port {port}')
        if result == 0:
            self.console.log(f'Port {port} connected on IP {ip} !')
            try:
                service = socket.getservbyport(port)
                self.console.log(f"SERVICE | {service} is currently running on PORT {port} with IP {ip}")
            except OSError:
                service = "Unknown service"
            banner = self.get_banner(self.tcp)
            open_ports[port] = {"state": "open", "service": service, "banner": banner}
        return open_ports

    def port_scanner(self, target, port, **kwargs):
        port_list = list()
        start_time = time.time()
        self.open_ports = {}
        open_ports = {}
        timeout = kwargs.get('timeout', None)
        verbose = kwargs.get('verbose', None)

        if timeout is None:
            timeout = 1
        if verbose is None:
            verbose = False
        else:
            verbose = True
        try:
            if type(port) != list:
                port_list.append(port)
            else:
                port_list = port.copy()
            target_ip = socket.gethostbyname(target)
        except socket.gaierror:
            self.console.log("Error: Unable to resolve the target IP address.")
            return False

        # Loop through the specified port range
        if type(port) == list:
            self.console.log(f'Scanning port from {port_list[0]} to {port_list[-1] + 1}')
        else:
            self.console.log(f'Scanning port {port}')
        for port in range(int(port_list[0]), int(port_list[-1]) + 1):
            self.tcp_scan((target_ip, port), open_ports,timeout, verbose)
        if not open_ports:
            print("No open ports found.")
        else:
            headers = {'port', 'state' 'service', 'banner'}
            table = Table()
            table.add_column("Port", style="cyan")
            table.add_column("State", style="magenta")
            table.add_column("Service", style="yellow")
            table.add_column("Banner", style="green")
            for port, details in open_ports.items():
                print(f"Port {port}: {details}")
                table.add_row(str(port), details['state'], details['service'], details['banner'])
                
            print(table)
        end_time = time.time()
        elapsed_time = end_time - start_time
        print(f"Scan completed in {elapsed_time:.2f} seconds.")
        return True

    def get_network_banner(self, ip, port):
        try:
            # Create a socket object for banner grabbing
            socket_obj = scapy.socket.socket(
                scapy.socket.AF_INET, scapy.socket.SOCK_STREAM)
            socket_obj.settimeout(1)  # Set a timeout for the connection attempt
            socket_obj.connect((ip, port))

            # Receive up to 1024 bytes of data from the socket
            banner = socket_obj.recv(1024).decode('utf-8').strip()
            socket_obj.close()
            return banner
        except (scapy.socket.timeout, scapy.socket.error):
            return "N/A"

    def detailed_network_scan(self, target):
        try:
            # Create an ARP request packet
            arp_request = scapy.ARP(pdst=target)

            # Create an Ethernet frame to encapsulate the ARP request
            broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")

            # Combine the Ethernet frame and ARP request
            arp_request_broadcast = broadcast/arp_request

            # Send the packet and receive the response
            answered_list = scapy.srp(arp_request_broadcast,
                                    timeout=1, verbose=False)[0]
            print(answered_list)
            # Extract and print detailed results
            print(f"Detailed Scan report for {target}")
            for element in answered_list:
                ip = element[1].psrc
                status = 'up' if element[1].haslayer(scapy.IP) else 'down'
                print(f"Host: {ip} is {status}")

                # If the host is up, perform additional scans
                if status == 'up':
                    # TCP scan on common ports (adjust as needed)
                    # common_ports = [21, 22, 80, 443, 3389]
                    common_ports = [i for i in range(0, 65535)]
                    for port in common_ports:
                        # Create a TCP packet
                        tcp_packet = scapy.layers.inet.TCP(
                            dst=ip, dport=port, flags="S")

                        # Send the packet and receive the response
                        response = scapy.sr1(tcp_packet, timeout=1, verbose=False)

                        # Check if the port is open
                        if response and response.haslayer(scapy.layers.inet.TCP):
                            print(f"  Port {port}: Open")

                            # Get banner information for open ports
                            banner = self.get_network_banner(ip, port)
                            print(f"    Banner: {banner}")

                            # Additional service detection (add more protocols as needed)
                            if response.haslayer(scapy.layers.inet.ICMP):
                                print("Service: ICMP")
                            elif response.haslayer(scapy.layers.inet.TCP):
                                print("Service: TCP")
                            elif response.haslayer(scapy.layers.inet.UDP):
                                print("Service: UDP")
        except Exception as e:
            print("An error occured:", e)
  
    def get_banner_mltd(self, socket_obj):
        try:
            # Receive up to 4096 bytes of data from the socket
            banner = socket_obj.recv(4096).decode('utf-8').strip()
            return banner
        except socket.timeout:
            return "Timeout"
        except UnicodeDecodeError:
            return "Unable to decode banner"

    def scan_port_mltd(self, target_ip, port, open_ports, conn_timeout):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as tcp_sock:
                tcp_sock.settimeout(conn_timeout)  # Set a timeout for the connection attempt
                
                # Attempt to connect to the target port
                result = tcp_sock.connect_ex((target_ip, port))

                # Check if the connection was successful
                if result == 0:
                    print(f'Scanning port {port}')
                    service = socket.getservbyport(port)
                    banner = self.get_banner_mltd(tcp_sock)
                    open_ports[port] = {"state": "open", "service": service, "banner": banner}
                # else:
                #     print(f"Port {port} is closed")

        except Exception as e:
            print(f"Error scanning port {port}: {str(e)}")
            
    def port_scanner_mltd(self, target, port, num_threads=10, conn_timeout=1):
        start_time = time.time()
        open_ports = {}
        flag = True
        port_range = list()
        if type(port) != list:
            port_range.append(port)
        else:
            port_range= port.copy()
        start_port = port_range[0]
        end_port = port_range[-1]
        try:
            # Resolve the target IP address
            target_ip = socket.gethostbyname(target)
        except socket.gaierror:
            print("Error: Unable to resolve the target IP address.")
            return False

        with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as executor:
            if len(port_range) == 2:    
                self.console.log(f"Scanning ports from {start_port} to {end_port}")
                futures = [executor.submit(self.scan_port_mltd, target_ip, port, open_ports, conn_timeout) for port in range(int(start_port), int(end_port) + 1)]
                concurrent.futures.wait(futures)
            else:
                port_range = list(set(port_range))  # Remove duplicates from the list
                port_str = ''
                for i, port in enumerate(port_range):
                    if i == 0:
                        port_str += str(port)
                    elif i == len(port_range) - 1:
                        port_str += f' and {port}.'
                    else:
                        port_str += f', {port}'
                self.console.log(f"Scanning ports {port_str}")
                # Submit scanning tasks to the executor
                futures = [executor.submit(self.scan_port_mltd, target_ip, port, open_ports, conn_timeout) for port in port_range]
                # Wait for all tasks to complete
                concurrent.futures.wait(futures)

        if not open_ports:
            self.console.log("No open ports found.")
        else:
            self.console.log("Open ports:")
            headers = {'port', 'state' 'service', 'banner'}
            table = Table()
            table.add_column("Port", style="cyan")
            table.add_column("State", style="magenta")
            table.add_column("Service", style="yellow")
            table.add_column("Banner", style="green")
            for port, details in open_ports.items():
                table.add_row(str(port), details['state'], details['service'], details['banner'])
            print(table)
        end_time = time.time()
        elapsed_time = end_time - start_time
        print(f"Scan completed in {elapsed_time:.2f} seconds.")
        return True

    def port_scanner_nmap(self, target, port_range, scan_type='-sSV -p'):
        start_time = time.time()
        open_ports = {}

        try:
            nm = nmap.PortScanner()

            # Check for different scan types
            nm.scan(hosts=target, arguments=f"{scan_type} {port_range}")
            for host in nm.all_hosts():
                if nm[host].state() == 'up':
                    for proto in nm[host].all_protocols():
                        port_info = nm[host][proto].items()
                        for port, port_data in port_info:
                            state = port_data['state']
                            service = port_data['name']
                            banner = port_data['product']
                            version = port_data['version'] if 'version' in port_data else None  # Check if version info available
                            open_ports[port] = {"state": state, "service": service, "banner": banner, "version": version}

            if not open_ports:
                print("No open ports found.")
            else:
                print("Open ports:")
                headers = {'port', 'state' 'service', 'banner'}
                table = Table()
                table.add_column("Port", style="cyan")
                table.add_column("State", style="magenta")
                table.add_column("Service", style="yellow")
                table.add_column("Banner", style="green")
                for port, details in open_ports.items():
                    table.add_row(str(port), details['state'], details['service'], details['banner'])
                # print(table)

        except Exception as e:
            print(f"Error during port scanning: {str(e)}")

        end_time = time.time()
        elapsed_time = end_time - start_time
        print(f"Scan completed in {elapsed_time:.2f} seconds.")
        return open_ports

    def get_channel(self, packet):
    # Extract channel information
        if packet.haslayer(scapy.Dot11Elt) and packet[scapy.Dot11Elt].ID == 3:
            return ord(packet[scapy.Dot11Elt].info)
        return None

    def get_mac_address(self, ip):
        # ARP request to get the MAC address of a device on the network
        arp_request = scapy.ARP(pdst=ip)
        broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
        arp_request_broadcast = broadcast / arp_request
        answered_list = scapy.srp(arp_request_broadcast, timeout=1, verbose=False)[0]

        # Return the MAC address of the first device found
        if answered_list:
            return answered_list[0][1].hwsrc
        else:
            return None

    def sniff_wireless_networks(self, interface):
        # Sniff wireless packets for a certain duration
        scapy.sniff(iface=interface, prn=self.process_packet, store=False,)

    def process_packet(self, packet, payload:int=20):
        if IP in packet:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            print(f"Source IP: {src_ip}, Destination IP: {dst_ip}")

            if TCP in packet:
                src_port = packet[TCP].sport
                dst_port = packet[TCP].dport
                print(f"TCP Source Port: {src_port}, Destination Port: {dst_port}")

                if packet[TCP].payload:
                    # Print payload (first 20 characters)
                    payload = packet[TCP].payload.load.decode('utf-8', errors='ignore')
                    print(f"Payload: {payload[:payload]}")

                    # Calculate data rate for TCP packets
                    timestamp = packet.sprintf("%sent.time%")
                    current_time = datetime.strptime(timestamp, "%H:%M:%S.%f")
                    elapsed_time = (self.start_time - current_time).total_seconds()
                    print(f'Timestamp: {timestamp}, Current Time: {current_time}, Start Time: {self.start_time}, Elapsed Time: {elapsed_time}, len of packet {len(packet)}')
                    if elapsed_time > 0:
                        data_rate = len(packet) / (1024 * elapsed_time)  # Convert to kilobytes per second
                        print(f"Data Rate: {data_rate:.2f} KB/s")
                        print()
                        print('Press Ctrl + C to stop')

            elif UDP in packet and hasattr(packet[UDP], 'payload') and hasattr(packet[UDP].payload, 'load'):
                dst_port = packet[UDP].dport
                print(f"UDP Source Port: {src_port}, Destination Port: {dst_port}")

                if packet[UDP].payload:
                    # Print payload (first 20 characters)
                    payload = packet[UDP].payload.load.decode('utf-8', errors='ignore')
                    print(f"Payload: {payload[:payload]}")
                    print()
                    print('Press Ctrl + C to stop')
            print()

        if packet.haslayer(scapy.Dot11):
            # Check for management frames (beacon and probe response)
            if packet.type == 0 and packet.subtype == 8:
                bssid = packet.addr2
                ssid = packet.info.decode('utf-8')
                channel = self.get_channel(packet)
                mac_address = self.get_mac_address(packet.addr3)
                print(f"SSID: {ssid}, BSSID: {bssid}, Channel: {channel}, mac-adress: {mac_address}")
                print()
                print('Press Ctrl + C to stop')

    def scan_headers(self, url):
        try:
            # Send a GET request to the target URL
            response = requests.get(url)

            # Check the HTTP status code
            if response.status_code == 200:
                print("Web application is accessible.")
                for key, value in response.headers.items():
                    print(f'{key} : {value}')
                    print()
                print()
                security_headers = response.headers.get("Strict-Transport-Security")
                if security_headers:
                    print(f"Strict-Transport-Security header found: {security_headers}")
                else:
                    print("Strict-Transport-Security header not found.")
                print()

                x_frame_options = response.headers.get('X-Frame-Options', '')
                if not x_frame_options:
                    print("X-Frame-Options is not properly configured. Vulnerable to clickjacking attacks.")
                
                print()
                x_content_type_options = response.headers.get('X-Content-Type-Options', '').lower()
                if x_content_type_options != 'nosniff':
                    print("X-Content-Type-Options is not properly configured. Vulnerable to MIME sniffing attacks.")

                print()
                referrer_policy = response.headers.get('Referrer-Policy', '').lower()
                if referrer_policy != 'same-origin':
                    print("Referrer-Policy is not properly configured. May expose sensitive information in referrers.")

                return True
            else:
                print(f"Failed to access web application. Status code: {response.status_code}")
                return False
        except requests.exceptions.RequestException as e:
            print(f"An error occurred while accessing the web application: {e}")
            return False
    
    def check_ssl_tls_configuration(self, target_host, target_port):
        try:
            context = ssl.create_default_context()
            with socket.create_connection((target_host, target_port)) as sock:
                with context.wrap_socket(sock, server_hostname=target_host) as ssock:
                    protocol_version = ssock.version()
                    print(f"SSL/TLS Protocol Version: {protocol_version}")
        except Exception as e:
            print(f"Error checking SSL/TLS configuration: {e}")

    def check_certificate_expiry(self, target_host, target_port):
        try:
            context = ssl.create_default_context()
            with socket.create_connection((target_host, target_port)) as sock:
                with context.wrap_socket(sock, server_hostname=target_host) as ssock:
                    cert = ssock.getpeercert()
                    expiry_date = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_until_expiry = (expiry_date - datetime.now()).days
                    print(f"Certificate Expiry Date: {expiry_date}, Days until expiry: {days_until_expiry}")
        except Exception as e:
            print(f"Error checking certificate expiry: {e}")

    def check_waf_presence(self, url):
        response = requests.get(url)
        if "X-WAF" in response.headers:
            print("Web Application Firewall (WAF) detected.")
            print(f"WAF Header: {response.headers['X-WAF']}")
        else:
            print("No WAF detected.")

    def send_request_mltd(self, url):
        response = requests.get(url)
        return response.status_code

    def check_dos_protection_mltd(self, target_url, num_requests=15):
        start_time = time.time()
        # Adjust the number of threads based on your needs
        num_threads = num_requests
        i = 0
        try:
            with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as executor:
                # Create a list of URLs to be tested
                urls = [target_url] * num_threads
                
                # Use executor.map to send requests concurrently
                i = 0
                for result in executor.map(self.send_request_mltd, urls):
                    i += 1
                    self.console.print(f'Request {i} sent. Response code: {result}')
                    self.console.clear(False)
                
                # Check for potential signs of DoS protection
                if 429 == result:  # HTTP status code for "Too Many Requests"
                    print("Denial-of-Service (DoS) protection is in place.")
                    return True
                else:
                    print("Denial-of-Service (DoS) protection may not be sufficient.")
                    print(f'A {num_threads} requests was made to {target_url} and there was no protection against too many requests.')
                    return False
        except ConnectionRefusedError:
            print("The connection was terminated.")
            print("Denial-of-Service (DoS) protection is in place.")
        except SSLError:
            print(f"SSLerror. Max retries exceeded with url {target_url}.")
            print("Denial-of-Service (DoS) protection is in place.")
        except ConnectTimeout:
            print(f"The connection timed out. Check your internet connection or the validity of the host {target_url}")
            print("Denial-of-Service (DoS) protection is in place.")
        except requests.exceptions.RequestException as e:
            print(f"A MAJOR ERROR OCCURED ON THE CONNECTION TO HOST {target_url}. Error details: {e}")
            print("Denial-of-Service (DoS) protection is in place.")

        end_time = time.time()
        elapsed_time = end_time - start_time
        print(f"Elapsed time: {elapsed_time:.2f} seconds")
        return True

    async def send_request_asyncio(self, session, url):
        async with session.get(url) as response:
            return response.status

    async def check_dos_protection_asyncio(self, target_url, num_requests=10):
        start_time = time.time()
        i = 0
        try:
            async with aiohttp.ClientSession() as session:
                tasks = [self.send_request_asyncio(session, target_url) for _ in range(num_requests)]
                i += 1
                results = await asyncio.gather(*tasks)

                # Check for potential signs of DoS protection
                print(requests)
                if 429 in results:  # HTTP status code for "Too Many Requests"
                    print("Denial-of-Service (DoS) protection is in place.")
                else:
                    print("Denial-of-Service (DoS) protection may not be sufficient.")
                    print(f'A {num_requests} requests was made to {target_url} and there was no protection against too many requests.')
        except ConnectionRefusedError:
            print("The connection was terminated.")
            print("Denial-of-Service (DoS) protection is in place.")
        except SSLError:
            print(f"SSLerror. Max retries exceeded with url {target_url}.")
            print("Denial-of-Service (DoS) protection is in place.")
        except ConnectTimeout:
            print(f"The connection timed out. Check your internet connection or the validity of the host {target_url}")
            print("Denial-of-Service (DoS) protection is in place.")
        except requests.exceptions.RequestException as e:
            print(f"A MAJOR ERROR OCCURED ON THE CONNECTION TO HOST {target_url}. Error details: {e}")
            print("Denial-of-Service (DoS) protection is in place.")
        end_time = time.time()
        elapsed_time = end_time - start_time
        print(f"Elapsed time: {elapsed_time:.2f} seconds")
        return True

    def get_network_interface(self):
        # Get a list of network interfaces
        interfaces = psutil.net_if_addrs()
        all_interfaces = ''''''
        for interface_name, addresses in interfaces.items():
            all_interfaces += f'Interface name: {interface_name} | Interface address: {addresses}\n'
        return all_interfaces

pentet = Pentester()
app = FastAPI()
console = Console()
pentest = Pentester()
os_name = platform.system()
SERVER_PORT:int = 8000
validate = InputValidator()

class PortScanRequest(BaseModel):
    ip: str
    url: str
    port: list
    thread: int
    num_request: int

class PortScanResponse(BaseModel):
    result: str

def start_server(module, port=8080):
    uvicorn.run(f'{module}:app')

@app.post("/port-scan/mltd/")
async def perform_port_scan_mltd(request: PortScanRequest):
    ip:str = request.ip
    port:str = request.port
    thread:int = request.thread
    result = pentet.port_scanner_mltd(ip, port, thread)
    return {"result": result}

@app.get("/port-scan/mltd/")
async def perform_port_scan_mltd_get(ip: str, port: str, thread: int):
    port_list: list = list()
    port_list.extend(port.split(' '))
    result = pentet.port_scanner_mltd(ip, port_list, thread)
    return {"result": result}

@app.post("/port-scan/nmap/")
async def perform_port_scan_nmap(request: PortScanRequest):
    ip:str = request.ip
    port:str = request.port
    thread:int = request.thread
    result = pentet.port_scanner_nmap(ip, port, thread)
    return {"result": result}

@app.get("/port-scan/nmap/")
async def perform_port_scan_nmap_get(ip: str, port: str, thread: int):
    port_list: list = list()
    port_list.extend(port.split(' '))
    result = pentet.port_scanner_nmap(ip, port_list, thread)
    return {"result": result}

@app.post("/port-scan/scan-headers/")
async def perform_headers_scan(request: PortScanRequest):
    url:str = request.url
    result = pentet.scan_headers(url)
    return {"result": result}

@app.get("/port-scan/scan-headers/")
async def perform_headers_scan_get(url):
    result = pentet.scan_headers(url)
    return {"result": result}

@app.post("/port-scan/scan-headers/")
async def perform_ddos_scan_mltd(request: PortScanRequest):
    url:str = request.url
    num_request: int = request.num_request
    result = pentet.check_dos_protection_mltd(url, num_request)
    return {"result": result}

@app.get("/port-scan/scan-headers/")
async def perform_ddos_scan_mltd_get(url, num_request):
    result = pentet.check_dos_protection_mltd(url, num_request)
    return {"result": result}

@app.post("/port-scan/scan-headers/")
async def perform_ddos_scan_asyncio(request: PortScanRequest):
    url:str = request.url
    num_request: int = request.num_request
    result = pentet.check_dos_protection_asyncio(url, num_request)
    return {"result": result}

@app.get("/port-scan/scan-headers/")
async def perform_ddos_scan_asyncio_get(url, num_request):
    result = pentet.check_dos_protection_asyncio(url, num_request)
    return {"result": result}

class PortScanRequest(BaseModel):
    ip: str
    url: str
    port: list
    thread: int
    num_request: int

class PortScanResponse(BaseModel):
    result: str
           
actions = """
## Select an action:
0. Exit

1. Port Scanner (Multi-thread optimization for speed).
    
2. Scan website header.
    
3. Detailed network scan.

5. Check DDOS protection on website (Multi-thread optimization for speed).

6. Check DDOS protection on website (Asyncio Process for speed).

"""

def use_cmd():
    flag_cmd = True
    while flag_cmd:
        print(actions)
        command_cmd = input("Select an action : ")
        print()

        if command_cmd == '1':
            print('Initialising Port Scanner Engines *_*_*_*')
            time.sleep(1)
            try:
                while True:
                    print("""
- a. Start Port scanner.
- b. Display usage/guide on port scanner.
- c. Go back""")
                    __sub_command = input("Select an option: ")
                    print()
                    if __sub_command:
                        if validate.is_str(__sub_command, length=1, raise_error=False):
                            if __sub_command == 'a':
                                print("Starting port scanning * * * ")
                                while True:
                                    ip = input("Enter IP-ADDRESS/URL to scan: ")
                                    print()
                                    if ip:
                                        break
                                    else:
                                        print('Enter a valid IP-ADDRESS/URL to scan: ')
                                        continue
                                while True:
                                    print('Enter port number(s) to scan. Port number should be seperated by space and entered in the following way:')
                                    print(
'''
- Scan single port: Enter a single port number to scan e.g --> 135 
- Scan a range of ports: Enter two numbers to scan where the first number is the start-port and the second number is the end-number e.g --> 135 445
- Scan different ports: Enter more than two ports to scan each of them e.g 135 139 443 80 650
'''
)
                                    port = input('Enter port to scan: ')
                                    print()
                                    if port:
                                        port_list = port.split(' ')
                                        for i in port_list:
                                            if not (i.isspace() or i.isdigit()):
                                                print("Invalid character detected %s"%(i))
                                                break
                                        port_list_ = list()
                                        for i in port_list:
                                            if i.isdigit():
                                                if int(i) > 65535:
                                                    print("Port number cannot exceed 65535. Enter a lower number.")
                                                else: port_list_.append(int(i))
                                        port_list_.sort()
                                        break
                                    else:
                                        print("Enter a valid port number : ")
                                        continue
                                while True:
                                    print(f"Enter number of thread to run process. Thread number should not exceed the highest port numner <Port -- {port_list_[-1]}")
                                    threads = input("--> ")
                                    print()
                                    if threads:
                                        if validate.is_int(threads):
                                            if int(threads) > port_list_[-1]:
                                                print(f"Threads should not exceed highest port value {port_list_[-1]}")
                                                continue
                                            else: break
                                        else: continue
                                timeout = 1
                                scanned = pentest.port_scanner_mltd(ip, port_list_, int(threads), timeout)
                                if scanned:
                                    print('\nScanning complete.\n') 
                                    try_again = input("Do you want to run scan again Y/N : ")
                                    print()
                                    if try_again.lower() == 'y':
                                        continue
                                    break
                            elif __sub_command == 'b':
                                print(Markdown(
'''
### Port Scanning Information
---
Port scanning is a crucial technique used in cybersecurity assessments to identify open ports on target systems. Open ports can indicate potential entry points for attackers or misconfigured services that could lead to security vulnerabilities.

#### Methodology:
1. **Port Scanning Techniques**: The Port Scanner employs multi-threaded port scanning techniques to efficiently scan a range of ports on a target system.
   
2. **TCP Connect Scan**: The scanner attempts to establish a TCP connection to each target port to determine if it is open, closed, or filtered.

3. **Banner Grabbing**: For open ports, the scanner performs banner grabbing to retrieve additional information, such as service identification and banner content.

4. **Concurrency**: Utilizes concurrent threading to improve scanning speed and efficiency, allowing multiple ports to be scanned simultaneously.

#### Features:
- **Custom Port Range**: Supports scanning of individual ports or a range of ports specified by the user.
  
- **Timeout Handling**: Incorporates timeout mechanisms to handle unresponsive ports and prevent scan delays.

- **Service Identification**: Identifies services running on open ports using the `socket.getservbyport()` function.

### Port Scanner Guide
#### Step-by-Step Instructions:
1. **Specify Target**: Enter the target hostname or IP address to scan for open ports.
   
2. **Select Port Range**: Choose the range of ports to scan, either single ports or a range specified as `start_port:end_port`.

3. **Configure Parameters**: Adjust the number of threads (`num_threads`) and connection timeout (`conn_timeout`) as needed for the scan.

4. **Initiate Scan**: Execute the `port_scanner_mltd()` method with the specified parameters to initiate the port scan.

5. **Review Results**: Once the scan is complete, review the output to identify open ports, their associated services, and banner information.

#### Tips:
- **Customization**: Adjust scan parameters based on network conditions and target requirements for optimal results.

- **Analysis**: Analyze scan results to identify potential security risks and prioritize remediation efforts.

- **Documentation**: Document findings and observations for reporting and future reference.

By following these guidelines, you can effectively conduct port scanning assessments using the provided Port Scanner functionality.
'''))
                            elif __sub_command == 'c':
                                print('Returning to action menu ... ')
                                time.sleep(1.5)
                                break
                            else:
                                print("Please enter a valid input [a-c]")
                        else:
                            print("Please enter a valid input [a-c]")
                    else: 
                        print("Please select an option for Port scanning.")
                        continue
            except Exception as e:
                print("An error occured:", e)


        elif command_cmd == '2':
            print('Setting up Web Header Scanner **-**-**')
            time.sleep(1)
            try:
                while True:
                    print("""
- a. Initialise web scanner.
- b. Display usage/guide on web header scanner.
- c. Go back
            """)
                    __sub_command = input("Select an option: ")
                    print()
                    if __sub_command:
                        if validate.is_str(__sub_command, length=1, raise_error=False):
                            if __sub_command == 'a':
                                print("Preparing the request module ...")
                                time.sleep(1)
                                while True:
                                    url = input("Enter the Website url to scan: ")
                                    print()
                                    if url:
                                        break
                                    else:
                                        continue
                                try:
                                    pentest.scan_headers(url)
                                    print('Scanning complete.') 
                                    try_again = input("Do you want to run scan again Y/N : ")
                                    print()
                                    if try_again.lower() == 'y':
                                        continue
                                    break
                                except Exception as e:
                                    print("An error occured while initiating web scan. Check that your [URL] is valid.")
                                    print(f"More error info: {e}")
                            elif __sub_command == 'b':
                                print(Markdown('''
### Web Application Header Scanning Information
Scanning web application headers is a critical step in cybersecurity assessments to identify security misconfigurations and potential vulnerabilities. This method sends a GET request to the target URL and analyzes the HTTP response headers for security-related information.

#### Methodology:
1. **HTTP Request**: Sends a GET request to the specified URL to retrieve the web application's response headers.

2. **Status Code Analysis**: Checks the HTTP status code to determine if the web application is accessible. A status code of 200 indicates success.

3. **Header Inspection**: Parses the response headers and examines key security-related headers, including `Strict-Transport-Security`, `X-Frame-Options`, `X-Content-Type-Options`, and `Referrer-Policy`.

4. **Vulnerability Detection**: Identifies potential vulnerabilities based on the presence or absence of security headers and their configurations.

#### Features:
- **Accessibility Check**: Verifies if the web application is accessible by examining the HTTP status code.
  
- **Security Header Analysis**: Inspects security-related headers to detect vulnerabilities such as clickjacking and MIME sniffing attacks.

- **Error Handling**: Handles exceptions gracefully to prevent scan interruptions and provides informative error messages.

### Web Application Header Scanning Guide
#### Step-by-Step Instructions:
1. **Specify Target URL**: Provide the URL of the target web application to scan its headers for security vulnerabilities.
   
2. **Initiate Scan**: Execute the `scan_headers()` method with the target URL as the parameter to start the header scanning process.

3. **Review Results**: Review the output to identify security headers, their configurations, and any potential vulnerabilities detected.

#### Tips:
- **Customization**: Modify the method to include additional header checks or customize the vulnerability detection logic based on specific requirements.
  
- **Continuous Monitoring**: Regularly scan web application headers to ensure ongoing security posture and compliance with best practices.

- **Documentation**: Document scan results, including identified vulnerabilities and recommended remediation steps, for reporting and future reference.

By following these guidelines, you can effectively scan web application headers for security vulnerabilities using the provided `scan_headers` method.
'''))
                            elif __sub_command == 'c':
                                print('Returning to action menu ... ')
                                time.sleep(1.5)
                                break
                            else:
                                print("Please enter a valid input [a-c]")
                        else:
                            print("Please enter a valid input [a-c]")   
                    else: 
                        print("Please select an option for Port scanning.")
                        continue
            except Exception as e:
                print("An error occured:", e)


        elif command_cmd == '3':
            print('Preparing network scan *_*_*_*')
            print()
            time.sleep(1)
            try:
                while True:
                    print("""
- a. Scan Interface
- b. Display usage/guide Network interface scan.
- c. Go back
            """)
                    __sub_command = input("Select an option: ")
                    print()
                    if __sub_command:
                        if validate.is_str(__sub_command, length=1, raise_error=False):
                            if __sub_command == 'a':
                                print("Detecting network interfaces ...")
                                try: net_interfaces = pentest.get_network_interface()
                                except: pass
                                if net_interfaces:
                                    __view_interface = input("Do you want to view the detected network interface on this machine Y/N ?")
                                    print()
                                    if __view_interface and __view_interface.lower() == 'y': print(net_interfaces)
                                    else: print('Skipping interface print-out')
                                while True:
                                    interface = input("Enter the network interface to scan: ")
                                    print()
                                    if interface:
                                        break
                                    else:
                                        continue
                                scanned = pentest.sniff_wireless_networks(interface)
                                if scanned:
                                    print('Scanning complete.') 
                                    try_again = input("Do you want to run scan again Y/N : ")
                                    print()
                                    if try_again.lower() == 'y':
                                        continue
                                    break
                            elif __sub_command == 'b':
                                print(Markdown('''

### Wireless Network Activity scan.
---

Wireless packet sniffing is a crucial technique in cybersecurity assessments to analyze network traffic, detect anomalies, and identify potential security threats. This method allows you to capture wireless packets on a specified network interface and inspect their contents for various purposes, including network monitoring, troubleshooting, and security analysis.

#### Methodology

Network Interface Selection: Choose the target network interface (e.g., Wi-Fi) on which you want to perform wireless packet sniffing.

Packet Capture: Utilize the `sniff` function provided by the Scapy library to capture wireless packets transmitted over the selected interface.

Packet Processing: Define a packet processing function (`process_packet`) to handle each captured packet. Extract relevant information from the packet headers, such as source and destination IP addresses, TCP/UDP ports, payload data, and wireless-specific details (e.g., SSID, BSSID, and channel).

Packet Analysis: Analyze the captured packets to understand network communication patterns, detect anomalies, and identify potential security issues, such as unauthorized access attempts, malicious activities, or misconfigured network devices.

#### Features

Interface Flexibility: Supports sniffing on various types of wireless network interfaces, including Wi-Fi, Bluetooth, and others, based on the provided interface name.

Real-Time Analysis: Provides real-time monitoring and analysis of wireless traffic, allowing for immediate detection and response to security incidents.

Customizable Processing: Allows customization of the packet processing logic to extract specific information or perform additional analysis based on the requirements of the security assessment.

Error Handling: Implements error handling mechanisms to gracefully handle exceptions and ensure uninterrupted packet capture and analysis.

Wireless Packet Sniffing Guide

#### Step-by-Step Instructions

Specify Network Interface: Choose the wireless network interface (e.g., "Wi-Fi" or "Bluetooth Network Connection") on which you want to perform packet sniffing.

Initiate Packet Capture: Execute the `sniff_wireless_networks` method with the selected network interface as the argument to start capturing wireless packets.

Analyze Captured Packets: Review the output generated by the `process_packet` function for each captured packet to analyze network traffic, extract relevant information, and identify potential security issues.

#### Tips:

Interface Selection: Ensure that the specified network interface supports wireless communication and has the necessary permissions for packet sniffing.

Packet Filtering: Implement packet filtering mechanisms to focus on specific types of traffic (e.g., HTTP, DNS) or exclude irrelevant packets from the analysis.

Data Privacy: Respect privacy regulations and ethical considerations when capturing and analyzing network packets, especially when dealing with sensitive or personal information.

By following these guidelines, you can effectively perform wireless packet sniffing using the provided `sniff_wireless_networks` method to enhance network security and mitigate potential risks.
'''))
                            elif __sub_command == 'c':
                                print('Returning to action menu ... ')
                                time.sleep(1.5)
                                break
                            else:
                                print("Please enter a valid input [a-c]")
                        else:
                            print("Please enter a valid input [a-c]")   
                    else: 
                        print("Please select an option for Port scanning.")
                        continue
            except Exception as e:
                print("An error occured:", e)

        elif command_cmd == '4':
            print('Attempting offensive DDOS scan --*-*--')
            print()
            time.sleep(1)
            try:
                while True:
                    print("""
- a. Test DDOS
- b. Display usage/guide on DDOS integrity test.
- c. Go back
            """)
                    __sub_command = input("Select an option: ")
                    print()
                    if __sub_command:
                        if validate.is_str(__sub_command, length=1, raise_error=False):
                            if __sub_command == 'a':
                                print("Starting port scanning ...")
                                while True:
                                    web_url = input("Enter web_url to test: ")
                                    print()
                                    if web_url:
                                        break
                                    else:
                                        continue
                                while True:
                                    num_requests = input("Enter number of requests: ")
                                    print()
                                    if num_requests and validate.is_int(num_requests) and int(num_requests) > 0:
                                        break
                                    else: 
                                        print(f"Invalid number of request entered: {num_requests}")
                                        continue
                                        
                                scanned = pentest.check_dos_protection_mltd(web_url, num_requests)
                                if scanned:
                                    print('Scanning complete.') 
                                    try_again = input("Do you want to run scan again Y/N : ")
                                    print()
                                    if try_again.lower() == 'y':
                                        continue
                                    break
                            elif __sub_command == 'b':
                                print(Markdown('''
### Denial-of-Service (DoS) Protection Check (using Multi-Threading for speed optimization.)
---

The `check_dos_protection_mltd` method is designed to assess whether a target web application has adequate protection against Denial-of-Service (DoS) attacks by sending a specified number of HTTP requests concurrently and analyzing the HTTP response codes.

#### Methodology

Request Sending: Sends multiple HTTP GET requests to the target URL concurrently using a ThreadPoolExecutor with the specified number of threads.

Response Analysis: Examines the HTTP response codes received from the target server. Specifically, it checks for the presence of the HTTP status code 429 (Too Many Requests), which indicates that the server has implemented rate limiting or DoS protection mechanisms.

DoS Protection Detection: Determines whether the target server exhibits signs of DoS protection based on the HTTP response codes received during the request sending process.

#### Features

Concurrent Request Sending: Utilizes concurrent programming techniques to send multiple HTTP requests concurrently, optimizing the scanning process for efficiency and speed.

Error Handling: Implements robust error handling mechanisms to handle various types of exceptions, such as connection errors, SSL errors, and request-related exceptions, ensuring the reliability of the scanning process.

Customizable Parameters: Allows customization of the number of requests to be sent (`num_requests`) and the maximum number of threads (`max_workers`) based on specific testing requirements.

DoS Protection Check Guide

#### Step-by-Step Instructions

Specify Target URL: Provide the URL of the target web application (`target_url`) that you want to test for DoS protection.

Adjust Parameters: Optionally adjust the number of requests to be sent (`num_requests`) and the maximum number of threads (`max_workers`) based on the desired testing intensity.

Initiate Protection Check: Execute the `check_dos_protection_mltd` method with the target URL and desired parameters to start the DoS protection assessment process.

Review Results: Review the output to determine whether the target web application has sufficient DoS protection mechanisms in place based on the detected HTTP response codes.

#### Tips

- Threshold Adjustment: Experiment with different values for the `num_requests` parameter to assess the server's response to varying levels of request volume and identify the threshold for triggering DoS protection mechanisms.

- Error Analysis: Analyze the specific error messages provided in case of connection errors or request-related exceptions to troubleshoot potential issues and refine the testing approach.

- Documentation: Document the results of the DoS protection assessment, including detected HTTP response codes and their implications, for reporting and future reference.

By following these guidelines, you can effectively evaluate the effectiveness of DoS protection mechanisms implemented by the target web application using the provided `check_dos_protection_mltd` method.
                                                       '''))
                            elif __sub_command == 'c':
                                print('Returning to action menu ... ')
                                time.sleep(1.5)
                                break
                            else:
                                print("Please enter a valid input [a-c]")
                        else:
                            print("Please enter a valid input [a-c]")   
                    else: 
                        print("Please select an option for Port scanning.")
                        continue
            except Exception as e:
                print("An error occured:", e)
       
        elif command_cmd == '5':
            print('Attempting offensive DDOS scan --*-*--')
            print()
            time.sleep(1)
            try:
                while True:
                    print("""
- a. Test DDOS
- b. Display usage/guide on DDOS integrity test.
- c. Go back
            """)
                    __sub_command = input("Select an option: ")
                    print()
                    if __sub_command:
                        if validate.is_str(__sub_command, length=1, raise_error=False):
                            if __sub_command == 'a':
                                print("Starting port scanning ...")
                                while True:
                                    web_url = input("Enter web_url to test: ")
                                    print()
                                    if web_url:
                                        break
                                    else:
                                        continue
                                while True:
                                    num_requests = input("Enter number of requests: ")
                                    print()
                                    if num_requests and validate.is_int(num_requests) and int(num_requests) > 0:
                                        break
                                    else: 
                                        print(f"Invalid number of request entered: {num_requests}")
                                        continue
                                        
                                scanned = pentest.check_dos_protection_asyncio(web_url, num_requests)
                                if scanned:
                                    print('Scanning complete.') 
                                    try_again = input("Do you want to run scan again Y/N : ")
                                    print()
                                    if try_again.lower() == 'y':
                                        continue
                                    break
                            elif __sub_command == 'b':
                                print(Markdown('''
### Asynchronous Denial-of-Service (DoS) Protection Check.
---

The `check_dos_protection_asyncio` method is designed to evaluate the effectiveness of Denial-of-Service (DoS) protection mechanisms implemented by a target web application by sending a specified number of asynchronous HTTP requests concurrently using the asyncio library and analyzing the HTTP response status codes.

#### Methodology:

- Request Sending: Sends multiple HTTP GET requests asynchronously to the target URL using aiohttp.ClientSession and asyncio.gather functions, with the specified number of requests.

- Response Analysis: Collects the HTTP response status codes received from the target server and checks for the presence of the HTTP status code 429 (Too Many Requests), indicating the activation of DoS protection mechanisms.

- DoS Protection Detection: Determines the presence or absence of sufficient DoS protection by analyzing the HTTP response status codes received during the asynchronous request sending process.

#### Features

- Asynchronous Request Sending: Utilizes asynchronous programming techniques with asyncio to send multiple HTTP requests concurrently, enhancing the efficiency and performance of the DoS protection assessment.

- Error Handling: Implements robust error handling mechanisms to handle various types of exceptions, such as connection errors, SSL errors, and request-related exceptions, ensuring the reliability and stability of the asynchronous request sending process.

- Customizable Parameters: Allows customization of the number of asynchronous requests to be sent (`num_requests`) based on specific testing requirements.

### Asynchronous DoS Protection Check Guide
---

#### Step-by-Step Instructions:

- Specify Target URL: Provide the URL of the target web application (`target_url`) that you want to test for DoS protection.

- Adjust Parameters: Optionally adjust the number of asynchronous requests to be sent (`num_requests`) based on the desired testing intensity.

- Initiate Protection Check: Execute the `check_dos_protection_asyncio` method with the target URL and desired parameters to start the asynchronous DoS protection assessment process.

- Review Results: Review the output to determine whether the target web application has sufficient DoS protection mechanisms in place based on the detected HTTP response status codes.

#### Tips

- Threshold Adjustment: Experiment with different values for the `num_requests` parameter to assess the server's response to varying levels of request volume and identify the threshold for triggering DoS protection mechanisms.

- Error Analysis: Analyze the specific error messages provided in case of connection errors or request-related exceptions to troubleshoot potential issues and refine the testing approach.

- Documentation: Document the results of the asynchronous DoS protection assessment, including detected HTTP response status codes and their implications, for reporting and future reference.

By following these guidelines, you can effectively evaluate the effectiveness of DoS protection mechanisms implemented by the target web application using the provided `check_dos_protection_asyncio` method.
                                                       '''))
                            elif __sub_command == 'c':
                                print('Returning to action menu ... ')
                                time.sleep(1.5)
                                break
                            else:
                                print("Please enter a valid input [a-c]")
                        else:
                            print("Please enter a valid input [a-c]")   
                    else: 
                        print("Please select an option for Port scanning.")
                        continue
            except Exception as e:
                print("An error occured:", e)

        elif command_cmd == '0':
            print("Termination in progress ...")
            time.sleep(3)
            print("Program terminated.")
            time.sleep(1)
            exit()

        else: print('Invalid action.')

def use_api():
    print('Starting API SERVER at http://127.0.0.1:8000/docs  or http://localhost:8000/docs \n\n')
    endpoints = {
        1: {'name': 'Port Scan MLTD POST', 'endpoint':'/port-list/mltd', 'method':'post/get'},
        2: {'name': 'Port Scan MLTD NMAP', 'endpoint':'/port-list/nmap', 'method':'post/get'},
        3: {'name': 'Scan Headers', 'endpoint': '/scan-headers/', 'method':'post/get'},
        4: {'name': 'DDOS Protection SCAN [MLTD]', 'endpoint': '/ddos-scan/mltd/', 'method':'post/get'},
        5: {'name': 'DDOS Protection SCAN [ASYNC]', 'endpoint': '/ddos-scan/async/', 'method':'post/get'},
    }
    intro_message = f'''
This project is currently configured to run on development servers only.
Enter the link on your browser to run Penetration tests and observe live data.

    '''
    print(intro_message)
    for i, j in endpoints.items():
        print(f'--> {i}.Name: {j["name"]}, Endpoint: {j["endpoint"]}, Method: {j["method"]} \n')

    try:
        # # Create the command list
        # command_list = ["cd", os.path.join(os.getcwd(), "Pentest"), "&&", "uvicorn", "start_cmd:app", "--reload"]

        # # Execute the command list
        # subprocess.run(command_list, shell=True, check=True)
        start_server(r'start_cmd')
    except subprocess.CalledProcessError as e:
        print(f"Error: {e}")
    except Exception as e:
        print("An error occurred with subprocess:", e)

if __name__ == '__main__':
    print(Markdown(Pentester().__doc_actions__))
    print()
    print()
    print('Do you want to execute this program as Commad line application or An API based application 0/1 ? ')
    flag = True
    while flag:
        try:
            command = input("Enter 1 for CMD or 0 for API : ")
            print()
            if validate.is_int(command) and command == '1':
                flag = False
                try:
                    use_cmd()
                except KeyboardInterrupt:
                    print("Execution Terminated.")
            elif validate.is_int(command) and command == '0':
                flag = False
                try:
                    # command = 'python -c "from Pentest.start_cmd import use_api; use_api()"'
                    # print("Command:", command)
                    # subprocess.run(command, shell=True, check=True)
                    use_api()
                except KeyboardInterrupt:
                    print("Execution Terminated.")
            else: print('Wrong Input')
                
        except ValueError:
            print(Markdown('Invalid value detected.\nPlease enter 1 or 0 for CMD or API respectively.'))
        except KeyboardInterrupt: 
            print('Execution Terminated')
            exit()
